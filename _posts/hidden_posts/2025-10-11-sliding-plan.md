---
# 포스트 제목
title: 슬라이딩 퍼즐과 군 예상 연재 계획

# author key값, _data/authors.yaml 에 있어야 정상적으로 표시됨
author: cotes 

# 포스트가 올라간 날짜. 한국은 GMT+09이므로 +0900 이다
date: 2019-08-08 11:33:00 +0800 

# 카테고리 세팅. n개의 배열이며, 순서대로 부모->자식 관계이다
categories: [Blogging, Demo]

# 태그 세팅. n 개의 배열이다.
tags: [typography]

# 미리보기 이미지 세팅. 필요없으면 비워도 됨
image:
  path: /assets/img/avatar/avatar-512x512.jpg
  alt: Responsive rendering of Chirpy theme on multiple devices.

# 홈에 pin으로 걸어놓을지 결정한다.
pin: false

# table of content를 사용할지 여부
toc: true

# 댓글을 열지 말지
comments: true

# mathjax 사용 여부
math: true

# mermaid 차트 사용 여부
mermaid: true

# 이 포스트를 보여줄지 말지
published: false

---

이 블로그 글을 연재할 생각임

https://lightaxis.github.io/posts/sliding-puzzle-and-group/


다음 포스팅으로 생각하는건 이런거임


두번째 포스팅 : 군의 기본 성질과 부분군
1. 군의 정의
2. 항등원의 유일성 증명
3. 역원의 유일성 증명
4. cancellation property 증명

5. 부분군의 정의
6. 부분군의 항등원이 항상 전체 군의 항등원과 같음을 증명
7. 부분군의 역원이 항상 전체 군의 역원과 같음을 증명



세번쨰 포스팅 : 대칭군과 케일리 정리
1. 유한 대칭군에 대한 소개, 단순한 permutation
2. 무한 대칭군으로의 확장, bijective map의 집합
3. 케일리 정리 소개
4. 케일리 정리의 증명
-> 왜 대칭군이 이토록 중요하게 다뤄지는지 언급
-> 대칭군 자체의 정의와 bijective mapping의 활용 방식 소개.



네번째 포스팅 : 짝순열과 홀순열
1. 순열의 부호의 정의
2. 순열의 표기, cycle notation
3. 순열의 분해, disjoint cycle로의 분해
4. 순열 부호의 uniqueness 증명. 
5. 순열 부호의 기본 성질 몇가지 합성하면 부호도 곱해짐 등등
-> 순열과 순열의 부호에 대한 기본 성질



다섯번째 포스팅 : 군 준동형 사상과 순열의 부호
1. 군 준동형 사상의 정의
2. 군 준동형 사상의 성질 : ker, 핵과 im, 상의 정의. 
3. 군 준동형 사상의 성질 : ker는 항상 부분군
4. 순열의 부호 함수가 군 준동형 사상임을 증명
5. 교대군의 정의 소개
-> 따라서 짝순열의 집합이 부분군임을 증명함.
-> 교대군 소개



여섯번째 포스팅 : 코셋과 라그랑주 정리
1. 코셋이란 무엇인지 소개
2. 코셋의 성질 : 부분군과 위수가 같음을 소개
3.. 코셋의 성질 : 전체군을 분할함을 소개
4. 라그랑주 정리 소개



일곱번째 포스팅 : 순열군의 절반은 짝순열
1. 순열군을 교대군으로 코셋 분해를 해봄
2. 정확히 2개의 코셋만 나옴을 증명
3. 라그랑주 정리에 의해, 그렇다면 교대군이 반드시 전체의 1/2임을 증명
4. 전체 순열 중, 정확히 절반은 짝순열, 나머지는 홀순열임을 증명



여덟번째 포스팅 : 슬라이딩 퍼즐의 불변량
1. 빈칸의 움직임이 어떤 불변량을 만드는지 확인, (반드시 짝수번의 교환만 가능)
2. 이를 통해 빈칸을 16번에 고정시킨 상태에서의 불변량으로써 순열의 부호가 유효함을 확인
3. 빈칸의 위치를 임의로 움직여도 어떤 불변량이 만들어지는지 확인 (빈칸의 부호까지 추가)
4. 빈칸의 부호까지 추가한 불변량으로 확장,
5. solvable이면, 반드시 다음의 불변량을 만족함을 증명
-> solvable \include Invariant(S_16) 을 증명
-> 하지만 이건 반대로 Invariant(S_16)이기만 하면 반드시 solvable인지는 보장하지 않음을 상기 



아홉번째 포스팅 : 불변량의 집합과 도달가능성(1)
1. 도달 가능성의 정의
2. Invariant(S_16) 이 엄연한 S_16의 부분집합임을 주의, 
즉 Invariant(S_16)이기만 하면 반대로 solvable인지는 또 다른 문제임을 상기
3. 모든 짝순열은 3-cycle로 분해될 수 있음을 증명. 즉 3-cycle을 임의의 원소에 대해서 가할 수 있다면 모든 짝순열을 만들어 낼 수 있음. 
4. conjugation과 conjugacy class 소개
5. 순열군의 conjugacy class의 생김새, 즉 3-cycle을 임의의 원소에 대해서 가할 수 있는 방법은 conjugation
-> 즉, conjugation을 실제 퍼즐에서 할 수 있다면, 이는 모든 짝순열을 생성 가능함을 의미한다는 결론



열번째 포스팅 : 슬라이딩 퍼즐의 해결 가능성 판정법
1. 이제 실제로 슬라이딩 퍼즐에서 3-cycle을 conjugation을 통해 임의의 세 원소로 바꾸는 방법을 소개
2. 이 아이디어를 사용하면 모든 종류의 S_15 짝순열을 16번 빈칸 상태에서 구현할 수 있음을 증명
3. 이제 불변량에 포함된, 빈칸이 움직일 때, 나머지 순열의 부호가 바뀌는 것도 도달 가능한지 증명
-> 이건 임의의 홀순열과, 빈칸이 음수 패리티에 있는 상태를 만들어야 함을 증명하는 것. 
이 임의의 홀순열 상태에서 빈칸을 정해진 규칙에 따라 16번 빈칸으로 옮겨버림. 
그러면 이건 짝순열 + 빈칸이 16번 상태에 잇는 어떤 상태가 됨. 

그런데 앞에서 빈칸이 16번 상태에 있는 그 어떤 짝순열이라도 구현 가능하므로,
결국 해당 짝순열 상태를 conjugation of 3-cycle을 통해 구현하고, 정해진 규칙에 따라 16번 빈칸으로 옮겼던 행동을 역으로 가해서 홀순열 + 빈칸이 음수 패리티에 있는 상황을 만들어 버리는게 가능함. 

4. Invariant(S_16) \include solvable 임을 증명 완료
앞에서 반대 방향의 포함관계도 증명했으므로, 
이제 해당 불변량을 만족하는 모든 상태와, solvable 상태가 동일한 집합임을 증명 완료. 

즉, solvable 하면 invariant를 만족하고, 
invariant를 만족하면 solvable 하다. 




열한번째 포스팅 : 슬라이딩 퍼즐을 맞출 확률은
1. 이제 아무 임의의 두 조각을 교환하는게 solvable과 unsolvable 상태를 진동시키는 지 증명
2. 슬라이딩 퍼즐 사이트의 해법이 정당함을 증명, 
3. 전체 군을 짝순열의 군이 양분한다는 것을 상기, 
아무렇게나 섞었을 때, 그 군이 홀순열일지 짝순열일지만이 중요, 즉 1/2임으로 결론

부록 : 
4. disjoint cycle로 분해 후, 그 사이클의 생김새로 짝순열, 홀순열을 구분하는 C++코드도 추가.

 

